#!/usr/bin/env python3
"""
Visualize ROI volumes and probability maps/labels generated by vessel_segmentation.py in napari.
If seg.* exists it loads and shows labels; otherwise shows probabilities.

Usage:
  python napari_vessel_segmentation_visualizer.py \
    --output-dir /workspace/outputs/nnUNet_inference/predictions_debug \
    [--only-with-roi-annotations]

Key bindings:
  - n: next case
  - p: previous case
  - v: toggle (per-class probabilities -> segmentation)
  - c: reset camera
  - o: adjust opacity (0.3 -> 0.5 -> 0.7 -> 0.9)
"""

from pathlib import Path
from typing import Dict, List, Optional, Tuple
import argparse
import json
import numpy as np
import napari


class NapariVesselSegmentationVisualizer:
    """Visualizer for outputs produced by vessel_segmentation.py."""

    def __init__(
        self,
        output_dir: str,
        only_with_roi_annotations: bool = False,
    ) -> None:
        self.output_dir = Path(output_dir)
        if not self.output_dir.exists():
            raise ValueError(f"Output directory not found: {self.output_dir}")

        # Filter option: show only cases that have roi_annotations.json
        self.only_with_roi_annotations = only_with_roi_annotations

        # Collect case list
        self.case_ids = self._collect_case_ids()
        if len(self.case_ids) == 0:
            raise ValueError(f"No cases found: {self.output_dir}")

        # napari state
        self.viewer: Optional[napari.Viewer] = None
        self.current_index = 0
        self.view_index = 0  # 0..(C-1): per-class prob, C: full segmentation
        self.opacity_levels = [0.3, 0.5, 0.7, 0.9]
        self.current_opacity_idx = 1  # default 0.5

        # Annotation state
        self.current_annotations = []
        self.current_annotation_index = 0
        self.show_annotations = True

        # Cache
        self._cache: Dict[str, Dict[str, object]] = {}

    def _find_extra_seg_files(self, case_dir: Path) -> Dict[str, Path]:
        """Find additional segmentation files under case folder."""

        results: Dict[str, Path] = {}
        for ext in ("npz", "npy"):
            for path in sorted(case_dir.glob(f"seg_*.{ext}")):
                if path.name in {"seg.npz", "seg.npy"}:
                    continue
                suffix = path.stem[4:]
                if not suffix:
                    suffix = "extra"
                if suffix not in results:
                    results[suffix] = path
        return results

    def _collect_case_ids(self) -> List[str]:
        """Collect sorted list of case IDs.

        - Required: either prob.npz/prob.npy or seg.npz/seg.npy must exist
        - Optional: when --only-with-roi-annotations is set, roi_annotations.json must also exist
        """
        ids = set()
        # Walk subdirectories and extract case IDs
        for case_dir in sorted(self.output_dir.iterdir()):
            if case_dir.is_dir():
                # Check for prob/seg npz or npy
                prob_npz = case_dir / "prob.npz"
                prob_npy = case_dir / "prob.npy"
                seg_npz = case_dir / "seg.npz"
                seg_npy = case_dir / "seg.npy"
                has_any = (
                    prob_npz.exists()
                    or prob_npy.exists()
                    or seg_npz.exists()
                    or seg_npy.exists()
                    or bool(self._find_extra_seg_files(case_dir))
                )
                if not has_any:
                    continue

                # Require roi_annotations.json when the option is enabled
                if self.only_with_roi_annotations:
                    roi_ann_path = case_dir / "roi_annotations.json"
                    if not roi_ann_path.exists():
                        continue

                ids.add(case_dir.name)
        return sorted(ids)

    def _load_case(self, case_id: str) -> Dict[str, object]:
        """Load case data into a dict cache."""
        if case_id in self._cache:
            return self._cache[case_id]

        out: Dict[str, object] = {}
        case_dir = self.output_dir / case_id

        # Resolve files (prefer npz; fallback to npy)
        prob_path_npz = case_dir / "prob.npz"
        prob_path_npy = case_dir / "prob.npy"
        seg_path_npz = case_dir / "seg.npz"
        seg_path_npy = case_dir / "seg.npy"
        extra_seg_paths = self._find_extra_seg_files(case_dir)

        # Prefer loading labels (seg) if present; otherwise probabilities
        if seg_path_npz.exists() or seg_path_npy.exists():
            seg_path = seg_path_npz if seg_path_npz.exists() else seg_path_npy
            if seg_path.suffix == ".npz":
                seg_data = np.load(seg_path)
                out["seg"] = seg_data["segmentation"].astype(np.uint32)
            else:
                out["seg"] = np.load(seg_path).astype(np.uint32)
            # If probabilities co-exist, load for toggling view
            if prob_path_npz.exists() or prob_path_npy.exists():
                ppath = prob_path_npz if prob_path_npz.exists() else prob_path_npy
                if ppath.suffix == ".npz":
                    prob_data = np.load(ppath)
                    out["probs"] = prob_data["probabilities"]
                else:
                    out["probs"] = np.load(ppath)
        else:
            # seg missing: probabilities are required
            if not (prob_path_npz.exists() or prob_path_npy.exists()):
                raise ValueError(f"No probability/label outputs found: {case_dir} (check prob.* or seg.*)")
            ppath = prob_path_npz if prob_path_npz.exists() else prob_path_npy
            if ppath.suffix == ".npz":
                prob_data = np.load(ppath)
                out["probs"] = prob_data["probabilities"]  # (C, Z, Y, X)
            else:
                out["probs"] = np.load(ppath)

        # ROI data (required)
        roi_npz = case_dir / "roi_data.npz"
        roi_npy = case_dir / "roi_data.npy"
        if not (roi_npz.exists() or roi_npy.exists()):
            raise ValueError(f"ROI data not found: {roi_npz} / {roi_npy}")
        if roi_npz.exists():
            roi_data = np.load(roi_npz)
            out["roi_volume"] = roi_data["roi"]
        else:
            out["roi_volume"] = np.load(roi_npy)
        out["has_roi"] = True

        # Transform info
        transform_path = case_dir / "transform.json"
        if transform_path.exists():
            with open(transform_path, "r") as f:
                transform_info = json.load(f)
                out["transform"] = transform_info

        # Load ROI annotations (produced by vessel_segmentation.py)
        roi_annotations_path = case_dir / "roi_annotations.json"
        if roi_annotations_path.exists():
            with open(roi_annotations_path, "r", encoding="utf-8") as f:
                roi_ann_data = json.load(f)
                annotations = roi_ann_data.get("roi_annotations", [])
                out["annotations"] = annotations
        else:
            out["annotations"] = []

        # Load additional segmentations
        extra_segs: Dict[str, np.ndarray] = {}
        for suffix, seg_path in extra_seg_paths.items():
            if seg_path.suffix == ".npz":
                seg_data = np.load(seg_path)
                seg_arr = seg_data["segmentation"].astype(np.uint32)
            else:
                seg_arr = np.load(seg_path).astype(np.uint32)
            extra_segs[suffix] = seg_arr
        out["extra_segs"] = extra_segs

        self._cache[case_id] = out
        return out

    def _normalize(self, vol: np.ndarray) -> np.ndarray:
        """Normalize volume (robust 1-99 percentile)."""
        vol = vol.astype(np.float32)
        p1, p99 = np.percentile(vol, [1, 99])
        if p99 > p1:
            vol = np.clip(vol, p1, p99)
            vol = (vol - p1) / (p99 - p1)
        else:
            vmin, vmax = vol.min(), vol.max()
            if vmax > vmin:
                vol = (vol - vmin) / (vmax - vmin)
        return vol

    def _probs_to_segmentation(self, probs: np.ndarray) -> np.ndarray:
        """Generate segmentation from probability maps (multi-class).

        Args:
            probs: probability maps (C, Z, Y, X)

        Returns:
            segmentation (Z, Y, X)
        """
        # argmax across classes
        seg = np.argmax(probs, axis=0).astype(np.uint32)
        return seg

    def _update_layers_for_case(self, case_id: str):
        """Update layers for the current case."""
        d = self._load_case(case_id)

        # Gather data
        probs = d.get("probs")  # (C, Z, Y, X) or None
        seg_label = d.get("seg")  # (Z, Y, X) or None
        extra_segs: Dict[str, np.ndarray] = d.get("extra_segs", {})  # suffix -> (Z, Y, X)
        roi_volume: np.ndarray = d["roi_volume"]  # ROI volume (required)
        transform: Optional[Dict] = d.get("transform")
        # Use voxel spacing in network space as scale; default (1,1,1)
        if transform and "spacing_after_resampling" in transform:
            # (Z, Y, X)
            scale: Tuple[float, float, float] = tuple(
                float(s) for s in transform.get("spacing_after_resampling", [1.0, 1.0, 1.0])
            )
        else:
            scale = (1.0, 1.0, 1.0)
        annotations: List[Dict] = d.get("annotations", [])

        # Clear layers
        self.viewer.layers.clear()

        # Show ROI image as base layer
        # If ROI volume is (C, Z, Y, X) with single channel, drop C-dim
        if roi_volume.ndim == 4 and roi_volume.shape[0] == 1:
            roi_volume = roi_volume[0]
        roi_normalized = self._normalize(roi_volume)
        self._add_image("ROI Image", roi_normalized, scale=scale, colormap="gray", opacity=1.0)

        # Print transform info
        if transform:
            print(f"\nTransform:")
            # Prefer refined ROI if available
            roi_bbox = transform.get("roi_bbox_network_refined") or transform.get("roi_bbox_network", [])
            if roi_bbox:
                roi_shape = [roi_bbox[i][1] - roi_bbox[i][0] for i in range(len(roi_bbox))]
                print(f"  ROI size: {roi_shape}")
                roi_off = transform.get("roi_offset_network_refined") or transform.get(
                    "roi_offset_network", []
                )
                print(f"  ROI offset: {roi_off}")
            print(f"  spacing(original): {transform.get('spacing_original', [])}")
            print(f"  spacing(network): {transform.get('spacing_after_resampling', [])}")

        # Determine number of classes (fallback from seg when probs absent)
        if isinstance(probs, np.ndarray):
            num_classes = int(probs.shape[0])
        elif isinstance(seg_label, np.ndarray):
            num_classes = int(seg_label.max()) + 1
        else:
            num_classes = 0
        opacity = self.opacity_levels[self.current_opacity_idx]

        # Toggle view based on view_index
        if (isinstance(probs, np.ndarray)) and (self.view_index < num_classes):
            # Probability mode (cycle classes)
            class_name = self._get_class_name(self.view_index)
            self._add_image(
                f"Prob: {class_name}",
                probs[self.view_index],
                scale=scale,
                colormap="magma",
                opacity=opacity,
            )
            self.viewer.title = (
                f"Vessel Segmentation - {case_id} - "
                f"Probability class {self.view_index}/{num_classes - 1} ({class_name})"
            )
        else:
            # Segmentation mode (use seg if present; else from probabilities)
            if isinstance(seg_label, np.ndarray):
                seg = seg_label.astype(np.uint32)
                seg_source = "labels"
            else:
                seg = self._probs_to_segmentation(probs)  # type: ignore[arg-type]
                seg_source = "probs→argmax"
            self._add_labels("Segmentation", seg, scale=scale, opacity=opacity)
            self.viewer.title = f"Vessel Segmentation - {case_id} - Segmentation({seg_source})"

        if extra_segs:
            for suffix, seg_extra in extra_segs.items():
                layer_name = f"Segmentation(extra:{suffix})"
                self._add_labels(layer_name, seg_extra.astype(np.uint32), scale=scale, opacity=opacity)

        # Show annotations (already converted by vessel_segmentation.py)
        if annotations:
            # roi_annotations.json provide ROI-space coordinates
            self.current_annotations = annotations
            self.current_annotation_index = 0

            if annotations and self.show_annotations:
                # Extract points
                points = []
                properties = {"location": [], "sop_uid": []}

                for ann in annotations:
                    if "roi_z" in ann and "roi_y" in ann and "roi_x" in ann:
                        points.append([ann["roi_z"], ann["roi_y"], ann["roi_x"]])
                        properties["location"].append(ann.get("location", "Unknown"))
                        sop_uid = ann.get("SOPInstanceUID", "")
                        properties["sop_uid"].append(sop_uid[:12] + "..." if len(sop_uid) > 12 else sop_uid)

                if points:
                    points_data = np.array(points)

                    # Text settings for points
                    text_parameters = {
                        "string": "location",
                        "anchor": "upper_left",
                        "translation": [0, 0, -20],
                        "size": 10,
                        "color": "yellow",
                    }

                    self._add_points(
                        "Annotations",
                        points_data,
                        size=8.0,
                        face_color="red",
                        # edge_color="yellow",
                        # edge_width=2,
                        properties=properties,
                        text=text_parameters,
                        scale=scale,
                    )

                    print(f"\nAnnotations: {len(points)}")
                    for i, ann in enumerate(annotations[:5]):  # show first 5
                        location = ann.get("location", "Unknown")
                        print(f"  {i+1}. {location}")
                    if len(annotations) > 5:
                        print(f"  ... and {len(annotations) - 5} more")
        else:
            self.current_annotations = []

        # Status
        status = f"Case {self.current_index + 1}/{len(self.case_ids)}"
        print(f"\n{status}")

    def _get_class_name(self, class_id: int) -> str:
        """Get class display name."""
        # Common class names for vessel segmentation
        class_names = {
            0: "background",
            1: "vessel",
            # Add more if multi-class
        }
        return class_names.get(class_id, f"class_{class_id}")

    def _add_image(self, name: str, data: np.ndarray, **kwargs):
        """Add image layer."""
        self.viewer.add_image(data, name=name, **kwargs)

    def _add_labels(self, name: str, data: np.ndarray, **kwargs):
        """Add labels layer."""
        self.viewer.add_labels(data, name=name, **kwargs)

    def _add_points(self, name: str, data: np.ndarray, **kwargs):
        """Add points layer."""
        self.viewer.add_points(data, name=name, **kwargs)

    def _setup_keybindings(self):
        """Set key bindings."""

        @self.viewer.bind_key("n")
        def _next_case(v):
            self.current_index = (self.current_index + 1) % len(self.case_ids)
            case_id = self.case_ids[self.current_index]
            print(f"\nNext case: {case_id}")
            self._update_layers_for_case(case_id)
            # If annotations exist, move to first annotation Z-slice
            if self.current_annotations:
                self._move_to_annotation(0)

        @self.viewer.bind_key("p")
        def _prev_case(v):
            self.current_index = (self.current_index - 1) % len(self.case_ids)
            case_id = self.case_ids[self.current_index]
            print(f"\nPrevious case: {case_id}")
            self._update_layers_for_case(case_id)
            # If annotations exist, move to first annotation Z-slice
            if self.current_annotations:
                self._move_to_annotation(0)

        @self.viewer.bind_key("v")
        def _toggle_view_mode(v):
            # Cycle: per-class prob -> segmentation -> back to start
            case_id = self.case_ids[self.current_index]
            d = self._load_case(case_id)
            probs = d.get("probs")
            num_classes = int(probs.shape[0]) if isinstance(probs, np.ndarray) else 0

            # Advance view_index
            self.view_index = (self.view_index + 1) % (num_classes + 1)

            if self.view_index < num_classes:
                class_name = self._get_class_name(self.view_index)
                print(f"Toggle -> Probability map: {class_name}")
            else:
                print("Toggle -> Segmentation")

            self._update_layers_for_case(case_id)

        @self.viewer.bind_key("o")
        def _toggle_opacity(v):
            self.current_opacity_idx = (self.current_opacity_idx + 1) % len(self.opacity_levels)
            opacity = self.opacity_levels[self.current_opacity_idx]
            print(f"Opacity: {opacity}")
            case_id = self.case_ids[self.current_index]
            self._update_layers_for_case(case_id)

        @self.viewer.bind_key("c")
        def _reset_camera(v):
            print("Camera reset")
            self.viewer.reset_view()

        @self.viewer.bind_key("a")
        def _toggle_annotations(v):
            self.show_annotations = not self.show_annotations
            print(f"Annotations: {'ON' if self.show_annotations else 'OFF'}")
            case_id = self.case_ids[self.current_index]
            self._update_layers_for_case(case_id)

        @self.viewer.bind_key("k")
        def _next_annotation(v):
            if not self.current_annotations:
                print("No annotations")
                return
            self.current_annotation_index = (self.current_annotation_index + 1) % len(
                self.current_annotations
            )
            ann = self.current_annotations[self.current_annotation_index]
            location = ann.get("location", "Unknown")
            z_slice = ann.get("roi_z", 0)
            msg = (
                f"Next annotation [{self.current_annotation_index + 1}/"
                f"{len(self.current_annotations)}]: {location} (Z={z_slice})"
            )
            print(msg)
            self._move_to_annotation(self.current_annotation_index)

        @self.viewer.bind_key("j")
        def _prev_annotation(v):
            if not self.current_annotations:
                print("No annotations")
                return
            self.current_annotation_index = (self.current_annotation_index - 1) % len(
                self.current_annotations
            )
            ann = self.current_annotations[self.current_annotation_index]
            location = ann.get("location", "Unknown")
            z_slice = ann.get("roi_z", 0)
            msg = (
                f"Previous annotation [{self.current_annotation_index + 1}/"
                f"{len(self.current_annotations)}]: {location} (Z={z_slice})"
            )
            print(msg)
            self._move_to_annotation(self.current_annotation_index)

        print("\nKey bindings:")
        print("  'n' - next case")
        print("  'p' - previous case")
        print("  'v' - toggle (per-class probs -> segmentation)")
        print("  'o' - opacity toggle")
        print("  'c' - reset camera")
        print("  'a' - annotations ON/OFF")
        print("  'k' - next annotation")
        print("  'j' - previous annotation")

    def run(self, start_index: int = 0, case_uid: Optional[str] = None) -> Optional[napari.Viewer]:
        """Run viewer."""
        if case_uid:
            try:
                matched_index = self.case_ids.index(case_uid)
                start_index = matched_index
                print(f"Starting with specified UID '{case_uid}' at index {matched_index + 1}")
            except ValueError:
                print(f"⚠ Specified UID '{case_uid}' not found")
                print("Available UIDs:")
                for i, cid in enumerate(self.case_ids[:10]):
                    print(f"  {i + 1}. {cid}")
                if len(self.case_ids) > 10:
                    print(f"  ... and {len(self.case_ids) - 10} more")
                print("Starting with default index")

        start_index = max(0, min(start_index, len(self.case_ids) - 1))
        self.current_index = start_index

        first_case = self.case_ids[self.current_index]
        print(f"\nFound {len(self.case_ids)} cases: {self.output_dir}")
        print(f"First case[{self.current_index + 1}]: {first_case}")

        self.viewer = napari.Viewer(title=f"Vessel Segmentation Viewer - {first_case}")
        self._setup_keybindings()
        self._update_layers_for_case(first_case)
        # If annotations exist, move to the first annotation Z-slice on initial display
        if self.current_annotations:
            self._move_to_annotation(0)
        return self.viewer

    def _move_to_annotation(self, index: int):
        """Move viewer to the specified annotation index."""
        if not self.current_annotations or index >= len(self.current_annotations):
            return

        ann = self.current_annotations[index]
        z_slice = ann.get("roi_z", 0)

        # Set viewer slice position
        if hasattr(self.viewer.dims, "current_step"):
            try:
                # Get current step
                current_step = list(self.viewer.dims.current_step)
                # Change Z only
                current_step[0] = z_slice
                self.viewer.dims.current_step = tuple(current_step)
            except Exception as e:
                print(f"Failed to move to annotation: {e}")


def main():
    parser = argparse.ArgumentParser(description="Vessel Segmentation Visualizer")
    parser.add_argument(
        "--output-dir",
        type=str,
        default="/workspace/data/nnUNet_inference/predictions_v4",
        # default="/workspace/outputs/nnUNet_inference/predictions_debug",
        help="Output directory of vessel_segmentation.py",
    )
    parser.add_argument(
        "--start-index",
        type=int,
        default=0,
        help="Starting case index",
    )
    parser.add_argument(
        "--uid",
        type=str,
        default=None,
        help="Specify SeriesInstanceUID to display",
    )
    parser.add_argument(
        "--only-with-roi-annotations",
        action="store_true",
        help="Show only cases that have roi_annotations.json",
    )

    args = parser.parse_args()

    viz = NapariVesselSegmentationVisualizer(
        output_dir=args.output_dir,
        only_with_roi_annotations=args.only_with_roi_annotations,
    )
    viewer = viz.run(start_index=args.start_index, case_uid=args.uid)
    if viewer is not None:
        napari.run()


if __name__ == "__main__":
    main()
